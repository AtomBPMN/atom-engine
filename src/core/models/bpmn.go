/*
This file is part of the AtomBPMN (R) project.
Copyright (c) 2025 Matreska Market LLC (ООО «Matreska Market»).
Authors: Matreska Team.

This project is dual-licensed under AGPL-3.0 and AtomBPMN Commercial License.
*/

package models

import (
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"time"
)

// BPMNProcess represents a BPMN process stored in database
// Представляет BPMN процесс хранящийся в базе данных
type BPMNProcess struct {
	BPMNID         string `json:"bpmn_id"` // Unique BPMN ID generated by our method
	ProcessID      string `json:"process_id"`
	ProcessName    string `json:"process_name"`
	Version        string `json:"version"`         // BPMN modeler version
	ProcessVersion int    `json:"process_version"` // Our internal version (1, 2, 3...)
	ContentHash    string `json:"content_hash"`    // Hash of original content for change detection
	IsExecutable   bool   `json:"is_executable"`

	// Extended data structures
	// Расширенные структуры данных
	Definitions   interface{} `json:"definitions,omitempty"`
	Collaboration interface{} `json:"collaboration,omitempty"`
	Process       interface{} `json:"process,omitempty"`

	Elements      map[string]interface{} `json:"elements"`
	ElementCounts map[string]int         `json:"element_counts"`
	ParsedAt      time.Time              `json:"parsed_at"`
	OriginalFile  string                 `json:"original_file"`
	Metadata      map[string]interface{} `json:"metadata"`
	Status        string                 `json:"status"` // active, inactive, deployed
	CreatedAt     time.Time              `json:"created_at"`
	UpdatedAt     time.Time              `json:"updated_at"`
}

// BPMNElement represents a generic BPMN element
// Представляет общий BPMN элемент
type BPMNElement struct {
	ID       string                 `json:"id"`
	Name     string                 `json:"name"`
	Type     string                 `json:"type"`
	Incoming []string               `json:"incoming,omitempty"`
	Outgoing []string               `json:"outgoing,omitempty"`
	Data     map[string]interface{} `json:"data,omitempty"`
}

// BPMNFile represents original BPMN file information
// Представляет информацию об оригинальном BPMN файле
type BPMNFile struct {
	ProcessID string    `json:"process_id"`
	Filename  string    `json:"filename"`
	Content   []byte    `json:"content"`
	Size      int64     `json:"size"`
	SavedAt   time.Time `json:"saved_at"`
	Hash      string    `json:"hash,omitempty"`
}

// NewBPMNProcess creates new BPMN process record
// Создает новую запись BPMN процесса
func NewBPMNProcess(processID, processName string) *BPMNProcess {
	now := time.Now()
	return &BPMNProcess{
		ProcessID:     processID,
		ProcessName:   processName,
		Elements:      make(map[string]interface{}),
		ElementCounts: make(map[string]int),
		Metadata:      make(map[string]interface{}),
		Status:        "active",
		CreatedAt:     now,
		UpdatedAt:     now,
	}
}

// ToJSON converts BPMN process to JSON
// Конвертирует BPMN процесс в JSON
func (bp *BPMNProcess) ToJSON() ([]byte, error) {
	return json.Marshal(bp)
}

// FromJSON creates BPMN process from JSON
// Создает BPMN процесс из JSON
func (bp *BPMNProcess) FromJSON(data []byte) error {
	return json.Unmarshal(data, bp)
}

// AddElement adds element to process
// Добавляет элемент в процесс
func (bp *BPMNProcess) AddElement(elementID string, element interface{}) {
	bp.Elements[elementID] = element
	bp.UpdatedAt = time.Now()
}

// GetElement gets element by ID
// Получает элемент по ID
func (bp *BPMNProcess) GetElement(elementID string) (interface{}, bool) {
	element, exists := bp.Elements[elementID]
	return element, exists
}

// GetElementsByType gets all elements of specific type
// Получает все элементы определенного типа
func (bp *BPMNProcess) GetElementsByType(elementType string) []interface{} {
	var elements []interface{}
	for _, element := range bp.Elements {
		if elementMap, ok := element.(map[string]interface{}); ok {
			if elemType, exists := elementMap["type"]; exists && elemType == elementType {
				elements = append(elements, element)
			}
		}
	}
	return elements
}

// UpdateElementCount updates element count for specific type
// Обновляет количество элементов для определенного типа
func (bp *BPMNProcess) UpdateElementCount(elementType string, count int) {
	bp.ElementCounts[elementType] = count
	bp.UpdatedAt = time.Now()
}

// GetTotalElements returns total number of business elements only (excluding metadata and diagram elements)
// Возвращает общее количество только бизнес-элементов (исключая метаданные и диаграммные элементы)
func (bp *BPMNProcess) GetTotalElements() int {
	businessCount := 0
	for _, element := range bp.Elements {
		if elementMap, ok := element.(map[string]interface{}); ok {
			if elementType, exists := elementMap["type"]; exists {
				if typeStr, ok := elementType.(string); ok {
					if bp.isBusinessElementType(typeStr) {
						businessCount++
					}
				}
			}
		}
	}
	return businessCount
}

// GetAllElements returns total number of all elements (including metadata)
// Возвращает общее количество всех элементов (включая метаданные)
func (bp *BPMNProcess) GetAllElements() int {
	return len(bp.Elements)
}

// isBusinessElementType checks if element type is a business element
// Проверяет является ли тип элемента бизнес-элементом
func (bp *BPMNProcess) isBusinessElementType(elementType string) bool {
	businessElements := []string{
		// Events
		"startEvent", "endEvent", "intermediateCatchEvent", "intermediateThrowEvent", "boundaryEvent",
		// Activities
		"task", "userTask", "serviceTask", "scriptTask", "sendTask", "receiveTask",
		"manualTask", "businessRuleTask", "callActivity", "subProcess",
		// Gateways
		"exclusiveGateway", "parallelGateway", "inclusiveGateway", "complexGateway", "eventBasedGateway",
		// Flows
		"sequenceFlow", "messageFlow", "association",
		// Data
		"dataObject", "dataStore", "dataStoreReference",
		// Structural
		"process", "collaboration", "participant",
	}

	for _, bizElement := range businessElements {
		if elementType == bizElement {
			return true
		}
	}
	return false
}

// SetStatus sets process status
// Устанавливает статус процесса
func (bp *BPMNProcess) SetStatus(status string) {
	bp.Status = status
	bp.UpdatedAt = time.Now()
}

// AddMetadata adds metadata field
// Добавляет поле метаданных
func (bp *BPMNProcess) AddMetadata(key string, value interface{}) {
	bp.Metadata[key] = value
	bp.UpdatedAt = time.Now()
}

// GetMetadata gets metadata field
// Получает поле метаданных
func (bp *BPMNProcess) GetMetadata(key string) (interface{}, bool) {
	value, exists := bp.Metadata[key]
	return value, exists
}

// GenerateBPMNID generates unique BPMN ID using our method
// Генерирует уникальный BPMN ID используя наш метод
func GenerateBPMNID() string {
	return GenerateID() // Use same method as timers
}

// GenerateContentHash generates SHA256 hash of content for change detection
// Генерирует SHA256 хеш контента для детекции изменений
func GenerateContentHash(content []byte) string {
	hasher := sha256.New()
	hasher.Write(content)
	return hex.EncodeToString(hasher.Sum(nil))
}

// GenerateProcessFilename generates versioned filename for process
// Генерирует версионированное имя файла для процесса
func GenerateProcessFilename(processID string, version int, originalFilename string) string {
	// Extract extension from original filename
	// Извлекаем расширение из оригинального имени файла
	ext := ".bpmn"
	if len(originalFilename) > 5 && originalFilename[len(originalFilename)-5:] == ".bpmn" {
		ext = ".bpmn"
	}

	return fmt.Sprintf("%s_v%d%s", processID, version, ext)
}
